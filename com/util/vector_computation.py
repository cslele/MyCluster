# -*- coding: utf-8 -*-

import numpy as np
from math import sqrt
import logging

def manyVectorDistance(vec_a, vec_b, distance_type="Euclidean"):
    """
    根据距离类型不同 求两个向量的距离(暂有欧式距离/余弦距离)
    :param vec_a:
    :param vec_b:
    :param distance_type: 默认是欧式距离
    :return:
    """
    try:
        # 欧式距离
        if distance_type == "Euclidean":
            # 计算向量a与向量b的欧式距离
            diff = vec_a - vec_b
            # dot计算矩阵内积
            return sqrt(np.dot(diff, diff))
        # 余弦距离
        elif distance_type == "Cosine":
            # np.linalg.norm 矩阵范数  默认二范数  各项平方的和 再开根号
            return np.dot(vec_a, vec_b)/(np.linalg.norm(vec_a)*np.linalg.norm(vec_b))
    except TypeError:
        logging.info("vec_a=%s" % vec_a)
        logging.info("vec_b=%s" % vec_b)
        return None

def averageVector(many_vectors, vector_weight, column_num):
    """
    求多个向量的权值向量
    :param many_vector:
    :column_num:向量列数
    :return:
    """
    average_vector = []
    # print(vector_weight)
    for i in range(0, column_num, 1):
        average_vector.append(0)
    row_num = len(many_vectors)
    # 先求出各个列权重之和  后面再求平均值
    row_index = 0
    for vector in many_vectors:
        for i in range(0, column_num, 1):
            average_vector[i] += vector_weight[row_index]*float(vector[i])
        row_index += 1

    for i in range(0, column_num, 1):
        average_vector[i] = average_vector[i] / row_num

    # 返回list类型的平均向量  [0.002,0.003,....]
    return average_vector

if __name__ == '__main__':
    aa = [[0.22234544,0.10139667,0.23706506,0.99640067,-0.49316494,-0.4007545
,0.60695533,0.36598611,0.33782611,-0.76305683,0.0122225,0.44388183
,0.46950517,0.45657561,-0.44724211,-0.26456839,0.04072072,0.47542572
,-0.26979189,-0.16269506,-0.03275517,0.50195922,0.25641267,0.15489217
,-0.20238911,0.06949094,0.050168,-0.18388411,0.62904428,0.28229128
,0.16162472,-0.13451039,0.02693,-0.57274622,-0.59755906,0.34571372
,-0.07276033,0.08454478,0.22151556,-0.35705822,0.41676067,-0.71386428
,0.54613033,0.11812706,0.65833622,-0.54994978,0.22266572,-0.5099595
,0.28851839,0.68773639,0.03551261,-0.23359478,0.03931578,-0.33699083
,-0.22018744,-0.88682956,-0.28148728,-0.63474928,-0.67096917,-0.67676628
,0.04105006,-0.53808094,0.53538156,0.67571283,-1.17763233,0.08715367
,-1.03172344,-0.102138,0.998776,-0.26661883,-0.37255417,0.28218711
,-0.2326775,0.51697767,-0.5108105,-0.45295272,-0.35161144,-0.22474056
,0.3860385,-0.10363356,0.18399817,-0.17409772,-0.01342294,-1.05689883
,-0.29952506,0.05486683,-0.33639183,0.11864156,0.4952285,0.62589556
,1.16914689,-0.17736328,0.05761439,0.4128935,0.076979,0.20689006
,-0.02125511,0.45811144,0.89747622,0.74975094],
[0.22234544,0.10139667,0.23706506,0.99640067,-0.49316494,-0.4007545
,0.60695533,0.36598611,0.33782611,-0.76305683,0.0122225,0.44388183
,0.46950517,0.45657561,-0.44724211,-0.26456839,0.04072072,0.47542572
,-0.26979189,-0.16269506,-0.03275517,0.50195922,0.25641267,0.15489217
,-0.20238911,0.06949094,0.050168,-0.18388411,0.62904428,0.28229128
,0.16162472,-0.13451039,0.02693,-0.57274622,-0.59755906,0.34571372
,-0.07276033,0.08454478,0.22151556,-0.35705822,0.41676067,-0.71386428
,0.54613033,0.11812706,0.65833622,-0.54994978,0.22266572,-0.5099595
,0.28851839,0.68773639,0.03551261,-0.23359478,0.03931578,-0.33699083
,-0.22018744,-0.88682956,-0.28148728,-0.63474928,-0.67096917,-0.67676628
,0.04105006,-0.53808094,0.53538156,0.67571283,-1.17763233,0.08715367
,-1.03172344,-0.102138,0.998776,-0.26661883,-0.37255417,0.28218711
,-0.2326775,0.51697767,-0.5108105,-0.45295272,-0.35161144,-0.22474056
,0.3860385,-0.10363356,0.18399817,-0.17409772,-0.01342294,-1.05689883
,-0.29952506,0.05486683,-0.33639183,0.11864156,0.4952285,0.62589556
,1.16914689,-0.17736328,0.05761439,0.4128935,0.076979,0.20689006
,-0.02125511,0.45811144,0.89747622,0.74975094]]

    print(averageVector(aa,len(aa[0])))
    print(manyVectorDistance(np.array(aa[0]),np.array(aa[1])))